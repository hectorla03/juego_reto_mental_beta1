<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Juego Reto Mental — HRAD</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root{ --amarillo:#FFCE00; --fondo:#111; --card:#1b1b1b; }
  body{overflow-x:hidden; margin:0; height:100vh; display:flex; align-items:center; justify-content:center; background:var(--fondo); color:#fff; font-family:Arial, sans-serif; }
  .wrap{ width:100%; max-width:820px; display:flex; gap:20px; padding:12px; box-sizing:border-box; }
  .left{ width:420px; background:var(--card); padding:16px; border-radius:8px; box-shadow:0 6px 20px rgba(0,0,0,.6); }
  .canvas-wrap{ position:relative; width:100%; max-width:360px; aspect-ratio:1/1; margin:0 auto; }
  canvas{ position:absolute; left:0; top:0; width:100%; height:100%; display:block; }
  h2{ margin:4px 0 10px; color:var(--amarillo); text-align:center; }
  .controls{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin-top:12px; }
  button{ padding:12px 14px; background:#333; color:#fff; border:1px solid #444; border-radius:8px; cursor:pointer; font-size:15px; touch-action: manipulation; min-height:44px; }
  input[type=number]{ width:72px; padding:6px; border-radius:6px; border:1px solid #444; background:#222; color:#fff }
  .right{ width:360px; background:var(--card); padding:16px; border-radius:8px; }
  .sides{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin-top:10px; }
  .side-btn{ width:60px; height:52px; border-radius:8px; background:#222; color:#fff; border:1px solid #444; font-weight:bold; cursor:pointer; font-size:16px; touch-action: manipulation; min-height:44px; }
  .side-btn.disabled{ opacity:0.45; pointer-events:none; }
  #log{ margin-top:14px; font-size:14px; min-height:80px; line-height:1.3; white-space:pre-wrap; color:#ddd }
  .small{ font-size:13px; color:#ccc; text-align:center; margin-top:6px; }
  @media (max-width: 600px){
    .wrap{ flex-direction:column; align-items:center; }
    .left, .right{ width:100%; max-width:420px; }
    .side-btn{ width:72px; height:56px; font-size:18px; }
    button{ font-size:16px; padding:12px 16px; }
  }
</style>
</head>
<body>

<div class="wrap">
  <div class="left">
    <h2>Identificación Rápida de la Triada Numérica Prevaleciente</h2>

    <div class="canvas-wrap">
      <canvas id="base" width="400" height="400"></canvas>
      <canvas id="top"  width="400" height="400"></canvas>
    </div>

    <div class="controls">
      <button id="start">Iniciar</button>
      <label class="small">Vueltas: <input id="vueltas" type="number" min="1" value="2"></label>
      <label class="small">Velocidad (pos/frame): <input id="vel" type="number" step="0.01" min="0.01" value="0.10"></label>
      <button id="revelar" style="background:#264653">Revelar resultados</button>
    </div>

    <div class="small">La ventana rotatoria revelará SOLO los números debajo del hueco. Pulsa Iniciar.</div>
  </div>

  <div class="right">
    <h2 style="font-size:18px">Seleccionar lado (A–F)</h2>
    <div class="sides" id="sides"></div>
    <div id="log"></div>
    <div class="small">Se garantiza un lado con suma estrictamente mayor.</div>
  </div>
</div>

<script>
// ---------------------- configuración / estado ----------------------
const canvasBase = document.getElementById('base');
const canvasTop  = document.getElementById('top');
const ctxB = canvasBase.getContext('2d');
const ctxT = canvasTop.getContext('2d');

const WIDTH = canvasBase.width, HEIGHT = canvasBase.height;
const CX = WIDTH/2, CY = HEIGHT/2;
const HEX_R = 150;
const NUM_R = 100;
const LETRAS = ['A','B','C','D','E','F'];
const total = 18; // 6*3

const SECTOR_COLORS = [
  'rgba(255,206,0,0.16)',  // A - amarillo
  'rgba(231,111,81,0.14)', // B
  'rgba(42,157,143,0.14)', // C
  'rgba(38,70,83,0.12)',   // D
  'rgba(155,89,182,0.14)', // E
  'rgba(241,196,15,0.14)'  // F
];

let lados = {}, rueda = [];
// slotPos: current position within a revolution [0..total]
// revolucionesDone counts completed passes (when reaching end 0 or total)
let slotPos = 1;               // starts centered in A (slot index 1)
let direction = 1;             // 1 = clockwise, -1 = counterclockwise
let revolucionesDone = 0;
let vueltasTarget = 1;

let speedIndex = 0.10, animando = false;
let selections = [], winner = null, generated = false;
let mostrarVentana = false;

// ---- angular constants (single source of truth) ----
const SLOT_STEP = (Math.PI * 2) / total;        // step per slot (18 slots)
const SECTOR_ANGLE = (Math.PI * 2) / 6;         // 6 sectors
// Choose START so center of sector 0 (A) is at -PI/2 (top horizontal side)
const START = -Math.PI/2 - (SECTOR_ANGLE / 2);

// UI elements
const btnStart = document.getElementById('start');
const inputVueltas = document.getElementById('vueltas');
const inputVel = document.getElementById('vel');
const btnRevelar = document.getElementById('revelar');
const sidesDiv = document.getElementById('sides');
const logDiv = document.getElementById('log');

// crear botones A-F (inicialmente deshabilitados)
LETRAS.forEach(l => {
  const b = document.createElement('button');
  b.innerText = l;
  b.className = 'side-btn disabled';
  b.disabled = true;
  b.addEventListener('click', ()=> onSelectSide(l,b));
  sidesDiv.appendChild(b);
});

// ---------------------- util ----------------------
function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function suma(arr){ return arr.reduce((s,v)=>s+v,0); }
function log(msg){
  const now = new Date().toLocaleTimeString();
  logDiv.innerText = `[${now}] ${msg}\n` + logDiv.innerText;
  console.log(msg);
}
// rounded rect helper compatible
function roundRectPath(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y,     x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x,     y + h, r);
  ctx.arcTo(x,     y + h, x,     y,     r);
  ctx.arcTo(x,     y,     x + w, y,     r);
  ctx.closePath();
}

// ---------------------- generar partida (ganador único) ----------------------
function generarPartida(){
  lados = {};
  const ganadorIdx = rand(0,5);
  const ganadorNums = [rand(7,9), rand(7,9), rand(7,9)];
  lados[LETRAS[ganadorIdx]] = ganadorNums;
  const ganSum = suma(ganadorNums);
  for(let i=0;i<6;i++){
    if(i===ganadorIdx) continue;
    let arr;
    do {
      arr = [rand(1,8), rand(1,8), rand(1,8)];
      if(suma(arr) >= ganSum) arr[0] = Math.max(1, arr[0]-1);
    } while(suma(arr) >= ganSum);
    lados[LETRAS[i]] = arr;
  }
  // construir rueda (A..F)
  rueda = [];
  LETRAS.forEach(l => rueda.push(...lados[l]));
  generated = true;
  winner = LETRAS[ganadorIdx];
  log('Partida generada (ganador oculto).');
  drawBase(); // pintar base ahora
}

// ---------------------- dibujar base (solo números + sectores) ----------------------
function drawBase(){
  try{
    if(!rueda || rueda.length !== total) return;
    ctxB.clearRect(0,0,WIDTH,HEIGHT);

    // 1️⃣ Sectores tipo pizza (triángulos hasta el borde del hexágono)
    for(let i = 0; i < 6; i++){
      const a1 = START + SECTOR_ANGLE * i;
      const a2 = START + SECTOR_ANGLE * (i + 1);

      ctxB.beginPath();
      ctxB.moveTo(CX, CY);
      ctxB.lineTo(
        CX + HEX_R * Math.cos(a1),
        CY + HEX_R * Math.sin(a1)
      );
      ctxB.lineTo(
        CX + HEX_R * Math.cos(a2),
        CY + HEX_R * Math.sin(a2)
      );
      ctxB.closePath();

      ctxB.fillStyle = SECTOR_COLORS[i];
      ctxB.fill();
    }

    // 2️⃣ Números alineados por sector (central en negrita)
    ctxB.fillStyle = '#fff';
    ctxB.textAlign = 'center';
    ctxB.textBaseline = 'middle';

    const subSlots = 3;
    let idx = 0;

    for(let s = 0; s < 6; s++){
      const sectorStart = START + SECTOR_ANGLE * s;
      const slotAngle = SECTOR_ANGLE / subSlots; // = SLOT_STEP

      for(let k = 0; k < subSlots; k++){
        if(idx >= rueda.length) break;

        const angle =
          sectorStart +
          slotAngle * k +
          slotAngle / 2;

        const x = CX + NUM_R * Math.cos(angle);
        const y = CY + NUM_R * Math.sin(angle);

        ctxB.font = (k === 1)
          ? 'bold 24px Arial'
          : '22px Arial';

        ctxB.fillText(String(rueda[idx]), x, y);
        idx++;
      }
    }

  } catch(err){
    log('drawBase error: ' + String(err));
    console.error(err);
  }
}

// ---------------------- dibujar top (overlay + hole + hex + letras + líneas externas) ----------------------
function drawTop(centerSlotPos, visibleSlots){
  try{
    ctxT.clearRect(0,0,WIDTH,HEIGHT);

    // overlay (cubre todo)
    ctxT.fillStyle = '#000';
    ctxT.fillRect(0,0,WIDTH,HEIGHT);

    // center angle for a fractional slot position
    const step = SLOT_STEP;
    const centerAngle = START + step * (centerSlotPos + 0.5);

    // rect size from slots arc
    const angularTotal = step * visibleSlots;
    const rectW = Math.max(70, NUM_R * angularTotal * 1.02);
    const rectH = 46;
    const corner = 12;

    // punch hole on top canvas (only if mostrarVentana)
    if(mostrarVentana){
      ctxT.save();
        ctxT.translate(CX,CY);
        ctxT.rotate(centerAngle);
        ctxT.translate(0, -NUM_R);
        ctxT.globalCompositeOperation = 'destination-out';
        roundRectPath(ctxT, -rectW/2, -rectH/2, rectW, rectH, corner);
        ctxT.fill();
      ctxT.restore();

      // borde de la ventana
      ctxT.globalCompositeOperation = 'source-over';
      ctxT.save();
        ctxT.translate(CX,CY);
        ctxT.rotate(centerAngle);
        ctxT.translate(0, -NUM_R);
        ctxT.strokeStyle = '#FFCE00';
        ctxT.lineWidth = 3;
        roundRectPath(ctxT, -rectW/2, -rectH/2, rectW, rectH, corner);
        ctxT.stroke();
      ctxT.restore();
    }

    // draw hexagon (flat-top) on top
    ctxT.save();
      ctxT.strokeStyle = '#FFCE00';
      ctxT.lineWidth = 3;
      ctxT.beginPath();
      for(let i=0;i<6;i++){
        const a = START + SECTOR_ANGLE * i + (SECTOR_ANGLE/2) - (Math.PI/6);
        const x = CX + HEX_R * Math.cos(a);
        const y = CY + HEX_R * Math.sin(a);
        if(i===0) ctxT.moveTo(x,y); else ctxT.lineTo(x,y);
      }
      ctxT.closePath();
      ctxT.stroke();

      // letters centered on each sector
      ctxT.fillStyle = '#fff';
      ctxT.font = '18px Arial';
      ctxT.textAlign = 'center';
      ctxT.textBaseline = 'middle';
      for(let i=0;i<6;i++){
        const ang = START + SECTOR_ANGLE * (i + 0.5);
        const x = CX + (HEX_R + 24) * Math.cos(ang);
        const y = CY + (HEX_R + 24) * Math.sin(ang);
        ctxT.fillText(LETRAS[i], x, y);
      }
    ctxT.restore();

    // Líneas divisorias externas (overlay fijo, siempre visibles)
    ctxT.save();
      ctxT.strokeStyle = 'rgba(255,206,0,0.95)';
      ctxT.lineWidth = 3;
      for(let i = 0; i < 6; i++){
        const angle = START + SECTOR_ANGLE * i;
        const x = CX + HEX_R * Math.cos(angle);
        const y = CY + HEX_R * Math.sin(angle);
        ctxT.beginPath();
        ctxT.moveTo(CX, CY);
        ctxT.lineTo(x, y);
        ctxT.stroke();
      }
    ctxT.restore();

  } catch(err){
    log('drawTop error: ' + String(err));
    console.error(err);
  }
}

// ---------------------- animation loop (with alternating direction per vuelta) ----------------------
const FPS = 50;
let lastTime = performance.now();

function render(){
  try{
    const visibleSlots = 3;
    drawTop(slotPos, visibleSlots);

    if(animando){
      // advance position within current revolution
      slotPos += speedIndex * direction;

      // crossing upper bound
      if(direction === 1 && slotPos >= total){
        // overshoot bounce
        slotPos = total - (slotPos - total);
        revolucionesDone++;
        direction = -1;
      }
      // crossing lower bound
      else if(direction === -1 && slotPos <= 0){
        slotPos = -slotPos;
        revolucionesDone++;
        direction = 1;
      }

      // finish condition
      if(revolucionesDone >= vueltasTarget){
        animando = false;
        onAnimationEnd();
      }
    }
  } catch(err){
    log('render error: ' + String(err));
    console.error(err);
  } finally {
    setTimeout(render, 1000 / FPS);
  }
}

// ---------------------- UI handlers ----------------------
btnStart.addEventListener('click', ()=>{
  const vueltas = Math.max(1, parseInt(inputVueltas.value,10) || 2);
  const vel = parseFloat(inputVel.value) || 0.08;
  speedIndex = Math.max(0.005, vel);

  generarPartida();
  selections = [];
  Array.from(sidesDiv.children).forEach(b=>{
    b.classList.add('disabled');
    b.disabled = true;
    b.style.background = '#222';
  });
  btnRevelar.disabled = false;
  log('Animando: memoriza los números en la ventana.');

  // init alternating spin
  vueltasTarget = vueltas;
  revolucionesDone = 0;
  direction = 1;     // start clockwise
  slotPos = 1;       // center of side A (indices 0,1,2 -> center=1)
  mostrarVentana = true;
  animando = true;
});

btnRevelar.addEventListener('click', ()=>{
  if(animando){ log('La rueda aún gira. Espera.'); return; }
  if(!generated){ log('Inicia una partida primero.'); return; }
  if(selections.length === 0){ log('Nadie seleccionó. Selecciona A–F antes de revelar.'); return; }
  revealSums();
});

function onSelectSide(letter, btnEl){
  selections.push(letter);
  btnEl.style.background = '#2a9d8f';
  btnEl.disabled = true;
  btnEl.classList.remove('disabled');
  log(`Seleccionado: ${selections.join(', ')}`);
}

function onAnimationEnd(){
  mostrarVentana = false;
  log('La ventana se detuvo y los números quedaron ocultos. Ahora seleccionen A–F.');
  Array.from(sidesDiv.children).forEach(b=>{
    b.disabled = false;
    b.classList.remove('disabled');
  });
}

function revealSums(){
  let html = 'Sumas por lado:\n';
  let max = -999, win = null;
  for(let l of LETRAS){
    const s = suma(lados[l]);
    html += `${l}: ${lados[l].join(' + ')} = ${s}\n`;
    if(s>max){ max=s; win=l; }
  }
  html += `\nLado ganador: ${win} (suma ${max})\n`;
  const acertantes = selections.filter(x=>x===win);
  html += acertantes.length>0 ? `Acertaron: ${acertantes.length}\n` : 'Nadie acertó.\n';
  log(html);
}

// ---------------------- start ----------------------
try{
  generarPartida();
  render();
  log('Listo. Pulsa INICIAR para animar la rueda.');
} catch(err){
  log('Inicialización error: ' + String(err));
  console.error(err);
}
</script>

</body>
</html>


